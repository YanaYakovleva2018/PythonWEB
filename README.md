**Домашнє завдання #1**

1. Намалюйте UML діаграму вашого випускного проекту "Персональний помічник" з минулого курсу. Для роботи можете скористатися безкоштовним draw.io або будь-яким іншим зручним для вас застосунком.
2. Ваш попередній застосунок зараз працює в консольному режимі та взаємодіє з користувачем у вигляді команд в консолі. Застосунок потрібно розвивати і частиною застосунку, що найчастіше змінюється, зазвичай є інтерфейс користувача (поки що це консоль). Модифікуйте код вашого застосунку, щоб представлення інформації користувачу (виведення карток з контактами користувача, нотатками, сторінка з інформацією про доступні команди) було легко змінити. Для цього потрібно описати абстрактний базовий клас для користувальницьких представлень та конкретні реалізації, які наслідують базовий клас та реалізують консольний інтерфейс.

**Домашнє завдання #2**

1. Зараз ваш проект "Персональний помічник", швидше за все, існує як пакет у системі, встановлений глобально, та використовує версію Python, яка встановлена в системі із встановленими в системі пакетами. Скористайтеся будь-яким зручним інструментом pipenv або poetry, на ваш вибір, для створення віртуального середовища для вашого застосунку. Зафіксуйте версію Python у цьому середовищі (вкажіть чітко: який Python слід використовувати) та налаштуйте ваше робоче середовище (IDE) для роботи зі створеним середовищем. Якщо використовували сторонні проекти, вони також повинні тепер мати конкретну версію.
2. Створіть Dockerfile, в якому встановіть "Персональний помічник" та запустіть його як окремий застосунок в окремому контейнері.

**Домашнє завдання #3**

_Перша частина для потоків_
Напишіть програму обробки папки "Мотлох", яка сортує файли у вказаній папці за розширеннями з використанням кількох потоків. Пришвидшіть обробку великих каталогів з великою кількістю вкладених папок та файлів за рахунок паралельного виконання обходу всіх папок в окремих потоках. Найвитратнішим за часом буде перенесення файлу та отримання списку файлів у папці (ітерація за вмістом каталогу). Щоб прискорити перенесення файлів, його можна виконувати в окремому потоці або пулі потоків. Це тим зручніше, що результат цієї операції ви в застосунку не обробляєте та можна не збирати жодних результатів. Щоб прискорити обхід вмісту каталогу з кількома рівнями вкладеності, ви можете обробку кожного підкаталогу виконувати в окремому потоці або передавати обробку в пул потоків.
_Друга частина для процесів_
Напишіть реалізацію функції factorize, яка приймає список чисел та повертає список чисел, на які числа із вхідного списку поділяються без залишку.
Реалізуйте синхронну версію та виміряйте час виконання.
Потім покращіть продуктивність вашої функції, реалізувавши використання кількох ядер процесора для паралельних обчислень і заміряйте час виконання знову. Для визначення кількості ядер на машині використовуйте функцію cpu_count() з пакета multiprocessing
Для перевірки правильності роботи алгоритму самої функції можете скористатися тестом:
def factorize(*number):
    # YOUR CODE HERE
    raise NotImplementedError() # Remove after implementation


a, b, c, d  = factorize(128, 255, 99999, 10651060)

assert a == [1, 2, 4, 8, 16, 32, 64, 128]
assert b == [1, 3, 5, 15, 17, 51, 85, 255]
assert c == [1, 3, 9, 41, 123, 271, 369, 813, 2439, 11111, 33333, 99999]
assert d == [1, 2, 4, 5, 7, 10, 14, 20, 28, 35, 70, 140, 76079, 152158, 304316, 380395, 532553, 760790, 1065106, 1521580, 2130212, 2662765, 5325530, 10651060]

**Домашнє завдання #4**

Ваша мета реалізувати найпростіший веб-додаток. За основу взяти наступні файли.
За аналогією з розглянутим прикладом у конспекті, створіть веб-додаток з маршрутизацією для двох html сторінок: index.html та message.html.
Також:
* Обробіть під час роботи програми статичні ресурси: style.css, logo.png;
* Організуйте роботу з формою на сторінці message.html;
* У разі виникнення помилки 404 Not Found повертайте сторінку error.html
* Ваша програма працює на порту 3000
Для роботи з формою створіть Socket сервер на порту 5000. Алгоритм роботи такий. Ви вводите дані у форму, вони потрапляють у ваш веб-додаток, який пересилає його далі на обробку за допомогою socket (протокол UDP), Socket серверу. Socket сервер переводить отриманий байт-рядок у словник і зберігає його в json файл data.json в папку storage.
Формат запису файлу data.json наступний:
{
  "2022-10-29 20:20:58.020261": {
    "username": "krabaton",
    "message": "First message"
  },
  "2022-10-29 20:21:11.812177": {
    "username": "Krabat",
    "message": "Second message"
  }
}

Де ключ кожного повідомлення - це час отримання повідомлення: datetime.now(). Тобто кожне нове повідомлення від веб-програми дописується до файлу storage/data.json з часом отримання.
Використовуйте для створення вашої веб-програми один файл main.py. Запустіть HTTP сервер і Socket сервер у різних потоках.
Додаткове завдання
Це додаткове завдання і його можна не виконувати для здачі цього домашнього завдання.
1. Створіть Dockerfile та запустіть ваш додаток як Docker-контейнер
2. За допомогою механізму volumes, зберігайте дані з storage/data.json не всередині контейнера

**Домашнє завдання #5**

Основна обов'язкова частина
Публічне АПІ ПриватБанка дозволяє отримати інформацію про готівку курсах валют ПриватБанку та НБУ на обрану дату. Архів зберігає дані за останні 4 роки
Напишіть консольну утиліту, яка повертає курс EUR та USD ПриватБанку протягом останніх кількох днів. Встановіть обмеження, що в утиліті можна дізнатися курс валют не більше, ніж за останні 10 днів. Для запиту до АПІ використовуйте Aiohttp client. Дотримуйтесь принципів SOLID під час написання завдання. Обробляйте коректно помилки при мережевих запитах.
Приклад роботи:
py .\main.py 2

Результат програми:
[
  {
    '03.11.2022': {
      'EUR': {
        'sale': 39.4,
        'purchase': 38.4
      },
      'USD': {
        'sale': 39.9,
        'purchase': 39.4
      }
    }
  },
  {
    '02.11.2022': {
      'EUR': {
        'sale': 39.4,
        'purchase': 38.4
      },
      'USD': {
        'sale': 39.9,
        'purchase': 39.4
      }
    }
  }
]


_Додаткова частина_
* додайте можливість вибору, через передані параметри консольної утиліти, додаткових валют у відповіді програми
* візьміть чат на веб-сокетах з лекційного матеріалу та додайте до нього можливість введення команди exchange. Вона показує користувачам поточний курс валют у текстовому форматі. Формат представлення виберіть на власний розсуд
* розширте додану команду exchange, щоб була можливість переглянути курс валют в чаті за останні кілька днів. Приклад exchange 2
* за допомогою пакетів aiofile та aiopath додайте логування до файлу, коли була виконана команда exchange у чаті

**Домашнє завдання #6**

_Основне завдання_
Реалізуйте базу даних, схема якої містить:
* Таблиця студентів;
* Таблицю груп;
* Таблицю викладачів;
* Таблицю предметів із вказівкою викладача, який читає предмет;
* Таблицю, де у кожного студента є оцінки з предметів із зазначенням коли оцінку отримано;
Заповніть отриману базу даних випадковими даними (~30-50 студентів, 3 групи, 5-8 предметів, 3-5 викладачів, до 20 оцінок у кожного студента з усіх предметів). Використовуйте пакет Faker для наповнення.
Зробити такі вибірки з отриманої бази даних:
1. Знайти 5 студентів із найбільшим середнім балом з усіх предметів.
2. Знайти студента із найвищим середнім балом з певного предмета.
3. Знайти середній бал у групах з певного предмета.
4. Знайти середній бал на потоці (по всій таблиці оцінок).
5. Знайти які курси читає певний викладач.
6. Знайти список студентів у певній групі.
7. Знайти оцінки студентів у окремій групі з певного предмета.
8. Знайти середній бал, який ставить певний викладач зі своїх предметів.
9. Знайти список курсів, які відвідує студент.
10. Список курсів, які певному студенту читає певний викладач.
Для кожного запиту оформити окремий файл query_number.sql, де замість number підставити номер запиту. Файл містить SQL інструкцію, яку можна виконати як у терміналі бази даних, так і через cursor.execute(sql)
_Додаткове завдання_
Для додаткового завдання зробіть такі запити підвищеної складності:
1. Середній бал, який певний викладач ставить певному студентові.
2. Оцінки студентів у певній групі з певного предмета на останньому занятті.

**Домашнє завдання #7**

Вступна
У цьому домашньому завданні ми продовжимо працювати з домашнім завданням із попереднього модуля.
В цій домашній роботі використаємо базу даних postgres. У командному рядку запустіть Docker контейнер:
docker run --name some-postgres -p 5432:5432 -e POSTGRES_PASSWORD=mysecretpassword -d postgres

Замість some-postgres виберіть свою назву контейнера, а замість mysecretpassword придумайте свій пароль для підключення до бази даних
CAUTION
За домовленістю з ментором та технічною неможливістю використовувати postgres, можна замінити її на SQLite
Кроки виконання домашнього завдання
Перший крок
Реалізуйте свої моделі SQLAlchemy, для таблиць:
* Таблиця студентів;
* Таблиця груп;
* Таблиця викладачів;
* Таблиця предметів із вказівкою викладача, який читає предмет;
* Таблиця де кожен студент має оцінки з предметів із зазначенням коли оцінку отримано;
Другий крок
Використовуйте alembic для створення міграцій у базі даних.
Третій крок
Напишіть скрипт seed.py та заповніть отриману базу даних випадковими даними (~30-50 студентів, 3 групи, 5-8 предметів, 3-5 викладачів, до 20 оцінок у кожного студента з усіх предметів). Використовуйте пакет Faker для наповнення. При заповненні використовуємо механізм сесій SQLAlchemy.
Четвертий крок
Зробити такі вибірки з отриманої бази даних:
1. Знайти 5 студентів із найбільшим середнім балом з усіх предметів.
2. Знайти студента із найвищим середнім балом з певного предмета.
3. Знайти середній бал у групах з певного предмета.
4. Знайти середній бал на потоці (по всій таблиці оцінок).
5. Знайти які курси читає певний викладач.
6. Знайти список студентів у певній групі.
7. Знайти оцінки студентів у окремій групі з певного предмета.
8. Знайти середній бал, який ставить певний викладач зі своїх предметів.
9. Знайти список курсів, які відвідує певний студент.
10. Список курсів, які певному студенту читає певний викладач.
Для запитів оформити окремий файл my_select.py, де будуть 10 функцій від select_1 до select_10. Виконання функцій повинно повертати результат аналогічний попередньої домашньої роботи. При запитах використовуємо механізм сесій SQLAlchemy.

_Додаткове завдання_
Перша частина
Для додаткового завдання зробіть такі запити підвищеної складності:
1. Середній бал, який певний викладач ставить певному студентові.
2. Оцінки студентів у певній групі з певного предмета на останньому занятті.
Друга частина
Замість скрипту seed.py подумайте та реалізуйте повноцінну CLI програму для CRUD операцій із базою даних. Використовуйте для цього модуль argparse .
Використовуйте команду --action або скорочений варіант -a для CRUD операцій. Та команду --model (-m) для вказівки над якою моделлю проводитися операція.
Приклад:
* --action create -m Teacher --name 'Boris Jonson' створення вчителя
* --action list -m Teacher показати всіх вчителів
* --action update -m Teacher --id 3 --name 'Andry Bezos' оновити дані вчителя з id=3
* --action remove -m Teacher --id 3 видалити вчителя з id=3
Реалізуйте ці операції для кожної моделі.

**Домашнє завдання #8**

Перша частина
Вихідні дані
У нас є json файл з авторами та їх властивостями: дата та місце народження, короткий опис біографії.
Вміст файлу `authors.json`.
Також ми маємо наступний json файл із цитатами від цих авторів.
Вміст файлу `quotes.json`.

_Додаткове завдання_
1. Подумайте та реалізуйте для команд name:Steve Martin та tag:life можливість скороченого запису значень для пошуку, як name:st та tag:li відповідно;
2. Виконайте кешування результату виконання команд name: та tag: за допомогою Redis, щоб при повторному запиті результат пошуку брався не з MongoDB бази даних, а з кешу;

Друга частина
Напишіть два скрипти: consumer.py та producer.py. Використовуючи RabbitMQ, організуйте за допомогою черг імітацію розсилки email контактам.
Використовуючи ODM Mongoengine, створіть модель для контакту. Модель обов'язково повинна включати поля: повне ім'я, email та логічне поле, яке має значення False за замовчуванням. Воно означає, що повідомлення контакту не надіслано і має стати True, коли буде відправлено. Інші поля для інформаційного навантаження можете придумати самі.
Під час запуску скрипта producer.py він генерує певну кількість фейкових контактів та записує їх у базу даних. Потім поміщає у чергу RabbitMQ повідомлення, яке містить ObjectID створеного контакту, і так для всіх згенерованих контактів.
Скрипт consumer.py отримує з черги RabbitMQ повідомлення, обробляє його та імітує функцією-заглушкою надсилання повідомлення по email. Після надсилання повідомлення необхідно логічне поле для контакту встановити в True. Скрипт працює постійно в очікуванні повідомлень з RabbitMQ.
Додаткове завдання
Введіть у моделі додаткове поле телефонний номер. Також додайте поле, що відповідає за кращий спосіб надсилання повідомлень — SMS по телефону або email. Нехай producer.py відправляє у різні черги контакти для SMS та email. Створіть два скрипти consumer_sms.py та consumer_email.py, кожен з яких отримує свої контакти та обробляє їх.

**Домашнє завдання #9**

Виберіть бібліотеку BeautifulSoup або фреймворк Scrapy. Ви повинні виконати скрапінг сайту http://quotes.toscrape.com. Ваша мета отримати два файли: qoutes.json, куди помістіть всю інформацію про цитати, з усіх сторінок сайту та authors.json, де буде знаходитись інформація про авторів зазначених цитат. Структура файлів json повинна повністю збігатися з попереднього домашнього завдання. Виконайте раніше написані скрипти для завантаження json файлів у хмарну базу даних для отриманих файлів. Попередня домашня робота повинна коректно працювати з новою отриманою базою даних.

**Домашнє завдання #10**

У минулій домашній роботі ви виконували скрапінг сайту http://quotes.toscrape.com.

Вам необхідно самостійно реалізувати аналог такого сайту на Django.

Реалізуйте можливість реєстрації на сайті та вхід на сайт.

Можливість додавання нового автора на сайт лише для зареєстрованого користувача.

Можливість додавання нової цитати на сайт із зазначенням автора тільки для зареєстрованого користувача.

Виконайте міграцію бази даних із MongoDB, яка у вас є, у Postgres для вашого сайту. Можна реалізувати кастомним скриптом. (За бажанням можете залишити та працювати з цитатами та авторами в MongoDB, а з користувачами у Postgres)

Можна зайти на сторінку кожного автора без аутентифікації користувача

Усі цитати доступні для перегляду без аутентифікації користувача

_Додаткова частина_

Реалізуйте пошук цитат за тегами. При натисканні на тег, виводиться список цитат з цим тегом.
Реалізуйте блок "Top Ten tags" та виведення найпопулярніших тегів.
Реалізуйте пагінацію. Це кнопки next та previous
Замість перенесення даних з бази даних MongoDB, реалізуйте можливість скрапінгу даних прямо з вашого сайту по натисканню певної кнопки на формі та наповнення бази даних сайту.


**Домашнє завдання #11**

Мета цього домашнього завдання — створити REST API для зберігання та управління контактами. API повинен бути побудований з використанням інфраструктури FastAPI та використовувати SQLAlchemy для управління базою даних.

Контакти повинні зберігатися в базі даних та містити наступну інформацію:

-Ім'я

-Прізвище

-Електронна адреса

-Номер телефону

-День народження

-Додаткові дані (необов'язково)

API повинен мати можливість виконувати наступні дії:

-Створити новий контакт

-Отримати список всіх контактів

-Отримати один контакт за ідентифікатором

-Оновити існуючий контакт

-Видалити контакт

На додаток до базового функціоналу CRUD API також повинен мати наступні функції:

Контакти повинні бути доступні для пошуку за ім'ям, прізвищем або адресою електронної пошти (Query).
API повинен мати змогу отримати список контактів з днями народження на найближчі 7 днів.

_Загальні вимоги_

Використання фреймворку FastAPI для створення API.
Використання ORM SQLAlchemy для роботи з базою даних.
В якості бази даних варто використовувати PostgreSQL.
Підтримка CRUD операцій для контактів.
Підтримка зберігання дати народження контакту.
Надання документів для API.
Використання модуля перевірки достовірності даних Pydantic.

**Домашнє завдання #12**

У цьому домашньому завданні ми продовжуємо допрацьовувати наш REST API застосунок із домашнього завдання 11.

_Завдання_

реалізуйте механізм аутентифікації в застосунку;

реалізуйте механізм авторизації за допомогою JWT токенів, щоб усі операції з контактами проводились лише зареєстрованими користувачами;

користувач має доступ лише до своїх операцій з контактами;

_Загальні вимоги_

При реєстрації, якщо користувач вже існує з таким email, сервер поверне помилку HTTP 409 Conflict;

Сервер хешує пароль і не зберігає його у відкритому вигляді в базі даних;

У разі успішної реєстрації користувача сервер повинен повернути HTTP статус відповіді 201 Created та дані нового користувача;

Для всіх операцій POST створення нового ресурсу, сервер повертає статус 201 Created;

При операції POST - аутентифікація користувача, сервер приймає запит із даними користувача (email, пароль) у тілі запиту;

Якщо користувач не існує або пароль не збігається, повертається помилка HTTP 401 Unauthorized;

механізм авторизації за допомогою JWT токенів реалізований парою токенів: токена доступу access_token і токен оновлення refresh_token;

**Домашнє завдання №13**

_Перша частина_

У цьому домашньому завданні ми продовжуємо доопрацьовувати застосунок REST API із домашнього завдання 12.

_Завдання_

Реалізуйте механізм верифікації електронної пошти зареєстрованого користувача;
Обмежуйте кількість запитів до своїх маршрутів контактів. Обов’язково обмежте швидкість створення контактів для користувача;
Увімкніть CORS для свого REST API;
Реалізуйте можливість оновлення аватара користувача. Використовуйте сервіс Cloudinary;

_Загальні вимоги_

Усі змінні середовища повинні зберігатися у файлі .env. Всередині коду не повинно бути конфіденційних даних у «чистому» вигляді;
Для запуску всіх сервісів і баз даних у застосунку використовується Docker Compose;

_Додаткове завдання_

Реалізуйте механізм кешування за допомогою бази даних Redis. Виконайте кешування поточного користувача під час авторизації;
Реалізуйте механізм скидання паролю для застосунку REST API;

_Друга частина_

У цьому домашньому завданні необхідно доопрацювати застосунок Django із домашнього завдання 10.

_Завдання_

Реалізуйте механізм скидання паролю для зареєстрованого користувача;
Усі змінні середовища повинні зберігатися у файлі .env та використовуватися у файлі settings.py;
